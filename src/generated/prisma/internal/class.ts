
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * Please import the `PrismaClient` class from the `client.ts` file instead.
 */

import * as runtime from "@prisma/client/runtime/client"
import type * as Prisma from "./prismaNamespace.js"


const config: runtime.GetPrismaClientConfig = {
  "previewFeatures": [],
  "clientVersion": "7.2.0",
  "engineVersion": "0c8ef2ce45c83248ab3df073180d5eda9e8be7a3",
  "activeProvider": "sqlite",
  "inlineSchema": "// This is your Prisma schema file,\n// learn more about it in the docs: https://pris.ly/d/prisma-schema\n\ngenerator client {\n  provider = \"prisma-client\"\n  output   = \"../src/generated/prisma\"\n}\n\ndatasource db {\n  provider = \"sqlite\"\n}\n\nmodel User {\n  id String @id @default(uuid())\n\n  fullName         String?  @map(\"full_name\")\n  // Telegram username without @ symbol\n  telegramUsername String?  @map(\"telegram_username\")\n  avatarUrl        String?  @map(\"avatar_url\")\n  // Unique Telegram user ID for authentication\n  telegramId       BigInt?  @unique @map(\"telegram_id\")\n  // System administrator flag for elevated permissions\n  isAdmin          Boolean  @default(false) @map(\"is_admin\")\n  // User ban status\n  isBanned         Boolean  @default(false) @map(\"is_banned\")\n  banReason        String?  @map(\"ban_reason\")\n  createdAt        DateTime @default(now()) @map(\"created_at\")\n  updatedAt        DateTime @updatedAt @map(\"updated_at\")\n  // User preferences stored as JSON string (SQLite limitation)\n  preferences      String   @default(\"{}\") // Store as JSON string in SQLite\n\n  ownedProjects  Project[]       @relation(\"ProjectOwner\")\n  projectMembers ProjectMember[]\n  publications   Publication[]   @relation(\"PublicationCreator\")\n  apiTokens      ApiToken[]\n\n  @@index([telegramUsername])\n  @@map(\"users\")\n}\n\nmodel ApiToken {\n  id              String    @id @default(uuid())\n  userId          String    @map(\"user_id\")\n  // User-friendly name for the token\n  name            String\n  // Hashed token for authentication (bcrypt/argon2)\n  hashedToken     String    @unique @map(\"hashed_token\")\n  // Encrypted token for one-time display to user\n  encryptedToken  String    @map(\"encrypted_token\")\n  // Array of project IDs this token has access to (JSON string)\n  scopeProjectIds String    @default(\"[]\") @map(\"scope_project_ids\")\n  // Last time this token was used for authentication\n  lastUsedAt      DateTime? @map(\"last_used_at\")\n  createdAt       DateTime  @default(now()) @map(\"created_at\")\n  updatedAt       DateTime  @updatedAt @map(\"updated_at\")\n\n  user User @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@index([userId])\n  @@map(\"api_tokens\")\n}\n\nmodel Project {\n  id          String    @id @default(uuid())\n  name        String\n  description String?\n  ownerId     String    @map(\"owner_id\")\n  createdAt   DateTime  @default(now()) @map(\"created_at\")\n  updatedAt   DateTime  @updatedAt @map(\"updated_at\")\n  // Timestamp when project was archived\n  archivedAt  DateTime? @map(\"archived_at\")\n  // User ID who archived the project\n  archivedBy  String?   @map(\"archived_by\")\n\n  owner        User            @relation(\"ProjectOwner\", fields: [ownerId], references: [id], onDelete: Cascade)\n  members      ProjectMember[]\n  channels     Channel[]\n  publications Publication[]\n\n  @@map(\"projects\")\n}\n\nmodel ProjectMember {\n  id        String      @id @default(uuid())\n  projectId String      @map(\"project_id\")\n  userId    String      @map(\"user_id\")\n  // User's role in the project (OWNER, ADMIN, EDITOR, VIEWER)\n  role      ProjectRole @default(VIEWER)\n  createdAt DateTime    @default(now()) @map(\"created_at\")\n\n  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)\n  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@unique([projectId, userId])\n  @@map(\"project_members\")\n}\n\nmodel Channel {\n  id                String      @id @default(uuid())\n  projectId         String      @map(\"project_id\")\n  // Social media platform type (TELEGRAM, INSTAGRAM, etc.)\n  socialMedia       SocialMedia @map(\"social_media\")\n  name              String\n  // Platform-specific channel identifier (e.g., @channel_name, channel_id)\n  channelIdentifier String      @map(\"channel_identifier\")\n  // Channel language in format like ru-RU, en-US, etc.\n  language          String\n  // Encrypted credentials for channel access stored as JSON string\n  credentials       String      @default(\"{}\") // Store as JSON string in SQLite\n  // Whether channel is active for posting\n  isActive          Boolean     @default(true) @map(\"is_active\")\n  createdAt         DateTime    @default(now()) @map(\"created_at\")\n  updatedAt         DateTime    @updatedAt @map(\"updated_at\")\n  // Timestamp when channel was archived\n  archivedAt        DateTime?   @map(\"archived_at\")\n  // User ID who archived the channel\n  archivedBy        String?     @map(\"archived_by\")\n\n  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)\n  posts   Post[]\n\n  @@index([projectId])\n  @@map(\"channels\")\n}\n\nmodel Publication {\n  id                 String  @id @default(uuid())\n  projectId          String  @map(\"project_id\")\n  // ID for linking translations of the same content\n  translationGroupId String? @map(\"translation_group_id\")\n\n  // User who created the publication (nullable for system-generated)\n  createdBy  String?   @map(\"created_by\")\n  createdAt  DateTime  @default(now()) @map(\"created_at\")\n  updatedAt  DateTime  @default(now()) @updatedAt @map(\"updated_at\")\n  // Timestamp when publication was archived\n  archivedAt DateTime? @map(\"archived_at\")\n  // User ID who archived the publication\n  archivedBy String?   @map(\"archived_by\")\n\n  title         String?\n  description   String?\n  content       String\n  // Comment from author for post with type NEWS\n  authorComment String?    @map(\"author_comment\")\n  tags          String?\n  // Array of media file URLs stored as JSON string\n  mediaFiles    String     @default(\"[]\") @map(\"media_files\")\n  // Additional metadata stored as JSON string\n  meta          String     @default(\"{}\")\n  // Type of post (POST, ARTICLE, VIDEO, etc.) - master type for distribution\n  postType      PostType   @default(POST) @map(\"post_type\")\n  // Date of the article which the author specified\n  postDate      DateTime?  @map(\"post_date\")\n  // Publication status (DRAFT, SCHEDULED, PUBLISHED, etc.)\n  status        PostStatus @default(DRAFT)\n  // Language of the publication (ru-RU, en-US, etc.)\n  language      String     @default(\"ru-RU\")\n\n  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)\n  creator User?   @relation(\"PublicationCreator\", fields: [createdBy], references: [id], onDelete: SetNull)\n  posts   Post[]\n\n  @@index([translationGroupId])\n  @@index([projectId, status])\n  @@index([projectId, createdAt])\n  @@map(\"publications\")\n}\n\nmodel Post {\n  id            String     @id @default(uuid())\n  // Link to parent publication\n  publicationId String     @map(\"publication_id\")\n  channelId     String     @map(\"channel_id\")\n  // Social media platform type stored as string for flexibility\n  socialMedia   String     @map(\"social_media\")\n  // Tags specific to this channel (can override publication tags)\n  tags          String?\n  // Post status for tracking publication success (DRAFT, SCHEDULED, PUBLISHED, FAILED, EXPIRED)\n  status        PostStatus @default(DRAFT)\n  // When post is scheduled to be published\n  scheduledAt   DateTime?  @map(\"scheduled_at\")\n  // Actual timestamp when post was published to platform\n  publishedAt   DateTime?  @map(\"published_at\")\n\n  createdAt DateTime @default(now()) @map(\"created_at\")\n  updatedAt DateTime @default(now()) @updatedAt @map(\"updated_at\")\n  // Archive flag (cascaded from publication)\n  archived  Boolean  @default(false)\n\n  publication Publication @relation(fields: [publicationId], references: [id], onDelete: Cascade)\n  channel     Channel     @relation(fields: [channelId], references: [id], onDelete: Cascade)\n\n  @@index([status, scheduledAt])\n  @@index([channelId, createdAt])\n  @@index([publicationId])\n  @@map(\"posts\")\n}\n\nenum ProjectRole {\n  OWNER\n  ADMIN\n  EDITOR\n  VIEWER\n}\n\nenum SocialMedia {\n  TELEGRAM\n  INSTAGRAM\n  VK\n  YOUTUBE\n  TIKTOK\n  X\n  FACEBOOK\n  LINKEDIN\n  SITE\n}\n\nenum PostType {\n  POST\n  ARTICLE\n  NEWS\n  VIDEO\n  SHORT\n  STORY\n}\n\nenum PostStatus {\n  DRAFT\n  SCHEDULED\n  PUBLISHED\n  FAILED\n  EXPIRED\n}\n",
  "runtimeDataModel": {
    "models": {},
    "enums": {},
    "types": {}
  }
}

config.runtimeDataModel = JSON.parse("{\"models\":{\"User\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"fullName\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"full_name\"},{\"name\":\"telegramUsername\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"telegram_username\"},{\"name\":\"avatarUrl\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"avatar_url\"},{\"name\":\"telegramId\",\"kind\":\"scalar\",\"type\":\"BigInt\",\"dbName\":\"telegram_id\"},{\"name\":\"isAdmin\",\"kind\":\"scalar\",\"type\":\"Boolean\",\"dbName\":\"is_admin\"},{\"name\":\"isBanned\",\"kind\":\"scalar\",\"type\":\"Boolean\",\"dbName\":\"is_banned\"},{\"name\":\"banReason\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"ban_reason\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\",\"dbName\":\"created_at\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"type\":\"DateTime\",\"dbName\":\"updated_at\"},{\"name\":\"preferences\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"ownedProjects\",\"kind\":\"object\",\"type\":\"Project\",\"relationName\":\"ProjectOwner\"},{\"name\":\"projectMembers\",\"kind\":\"object\",\"type\":\"ProjectMember\",\"relationName\":\"ProjectMemberToUser\"},{\"name\":\"publications\",\"kind\":\"object\",\"type\":\"Publication\",\"relationName\":\"PublicationCreator\"},{\"name\":\"apiTokens\",\"kind\":\"object\",\"type\":\"ApiToken\",\"relationName\":\"ApiTokenToUser\"}],\"dbName\":\"users\"},\"ApiToken\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"userId\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"user_id\"},{\"name\":\"name\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"hashedToken\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"hashed_token\"},{\"name\":\"encryptedToken\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"encrypted_token\"},{\"name\":\"scopeProjectIds\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"scope_project_ids\"},{\"name\":\"lastUsedAt\",\"kind\":\"scalar\",\"type\":\"DateTime\",\"dbName\":\"last_used_at\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\",\"dbName\":\"created_at\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"type\":\"DateTime\",\"dbName\":\"updated_at\"},{\"name\":\"user\",\"kind\":\"object\",\"type\":\"User\",\"relationName\":\"ApiTokenToUser\"}],\"dbName\":\"api_tokens\"},\"Project\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"name\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"description\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"ownerId\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"owner_id\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\",\"dbName\":\"created_at\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"type\":\"DateTime\",\"dbName\":\"updated_at\"},{\"name\":\"archivedAt\",\"kind\":\"scalar\",\"type\":\"DateTime\",\"dbName\":\"archived_at\"},{\"name\":\"archivedBy\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"archived_by\"},{\"name\":\"owner\",\"kind\":\"object\",\"type\":\"User\",\"relationName\":\"ProjectOwner\"},{\"name\":\"members\",\"kind\":\"object\",\"type\":\"ProjectMember\",\"relationName\":\"ProjectToProjectMember\"},{\"name\":\"channels\",\"kind\":\"object\",\"type\":\"Channel\",\"relationName\":\"ChannelToProject\"},{\"name\":\"publications\",\"kind\":\"object\",\"type\":\"Publication\",\"relationName\":\"ProjectToPublication\"}],\"dbName\":\"projects\"},\"ProjectMember\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"projectId\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"project_id\"},{\"name\":\"userId\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"user_id\"},{\"name\":\"role\",\"kind\":\"enum\",\"type\":\"ProjectRole\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\",\"dbName\":\"created_at\"},{\"name\":\"project\",\"kind\":\"object\",\"type\":\"Project\",\"relationName\":\"ProjectToProjectMember\"},{\"name\":\"user\",\"kind\":\"object\",\"type\":\"User\",\"relationName\":\"ProjectMemberToUser\"}],\"dbName\":\"project_members\"},\"Channel\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"projectId\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"project_id\"},{\"name\":\"socialMedia\",\"kind\":\"enum\",\"type\":\"SocialMedia\",\"dbName\":\"social_media\"},{\"name\":\"name\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"channelIdentifier\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"channel_identifier\"},{\"name\":\"language\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"credentials\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"isActive\",\"kind\":\"scalar\",\"type\":\"Boolean\",\"dbName\":\"is_active\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\",\"dbName\":\"created_at\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"type\":\"DateTime\",\"dbName\":\"updated_at\"},{\"name\":\"archivedAt\",\"kind\":\"scalar\",\"type\":\"DateTime\",\"dbName\":\"archived_at\"},{\"name\":\"archivedBy\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"archived_by\"},{\"name\":\"project\",\"kind\":\"object\",\"type\":\"Project\",\"relationName\":\"ChannelToProject\"},{\"name\":\"posts\",\"kind\":\"object\",\"type\":\"Post\",\"relationName\":\"ChannelToPost\"}],\"dbName\":\"channels\"},\"Publication\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"projectId\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"project_id\"},{\"name\":\"translationGroupId\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"translation_group_id\"},{\"name\":\"createdBy\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"created_by\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\",\"dbName\":\"created_at\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"type\":\"DateTime\",\"dbName\":\"updated_at\"},{\"name\":\"archivedAt\",\"kind\":\"scalar\",\"type\":\"DateTime\",\"dbName\":\"archived_at\"},{\"name\":\"archivedBy\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"archived_by\"},{\"name\":\"title\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"description\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"content\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"authorComment\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"author_comment\"},{\"name\":\"tags\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"mediaFiles\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"media_files\"},{\"name\":\"meta\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"postType\",\"kind\":\"enum\",\"type\":\"PostType\",\"dbName\":\"post_type\"},{\"name\":\"postDate\",\"kind\":\"scalar\",\"type\":\"DateTime\",\"dbName\":\"post_date\"},{\"name\":\"status\",\"kind\":\"enum\",\"type\":\"PostStatus\"},{\"name\":\"language\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"project\",\"kind\":\"object\",\"type\":\"Project\",\"relationName\":\"ProjectToPublication\"},{\"name\":\"creator\",\"kind\":\"object\",\"type\":\"User\",\"relationName\":\"PublicationCreator\"},{\"name\":\"posts\",\"kind\":\"object\",\"type\":\"Post\",\"relationName\":\"PostToPublication\"}],\"dbName\":\"publications\"},\"Post\":{\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"publicationId\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"publication_id\"},{\"name\":\"channelId\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"channel_id\"},{\"name\":\"socialMedia\",\"kind\":\"scalar\",\"type\":\"String\",\"dbName\":\"social_media\"},{\"name\":\"tags\",\"kind\":\"scalar\",\"type\":\"String\"},{\"name\":\"status\",\"kind\":\"enum\",\"type\":\"PostStatus\"},{\"name\":\"scheduledAt\",\"kind\":\"scalar\",\"type\":\"DateTime\",\"dbName\":\"scheduled_at\"},{\"name\":\"publishedAt\",\"kind\":\"scalar\",\"type\":\"DateTime\",\"dbName\":\"published_at\"},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"type\":\"DateTime\",\"dbName\":\"created_at\"},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"type\":\"DateTime\",\"dbName\":\"updated_at\"},{\"name\":\"archived\",\"kind\":\"scalar\",\"type\":\"Boolean\"},{\"name\":\"publication\",\"kind\":\"object\",\"type\":\"Publication\",\"relationName\":\"PostToPublication\"},{\"name\":\"channel\",\"kind\":\"object\",\"type\":\"Channel\",\"relationName\":\"ChannelToPost\"}],\"dbName\":\"posts\"}},\"enums\":{},\"types\":{}}")

async function decodeBase64AsWasm(wasmBase64: string): Promise<WebAssembly.Module> {
  const { Buffer } = await import('node:buffer')
  const wasmArray = Buffer.from(wasmBase64, 'base64')
  return new WebAssembly.Module(wasmArray)
}

config.compilerWasm = {
  getRuntime: async () => await import("@prisma/client/runtime/query_compiler_bg.sqlite.mjs"),

  getQueryCompilerWasmModule: async () => {
    const { wasm } = await import("@prisma/client/runtime/query_compiler_bg.sqlite.wasm-base64.mjs")
    return await decodeBase64AsWasm(wasm)
  }
}



export type LogOptions<ClientOptions extends Prisma.PrismaClientOptions> =
  'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never

export interface PrismaClientConstructor {
    /**
   * ## Prisma Client
   * 
   * Type-safe database client for TypeScript
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   * 
   * Read more in our [docs](https://pris.ly/d/client).
   */

  new <
    Options extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
    LogOpts extends LogOptions<Options> = LogOptions<Options>,
    OmitOpts extends Prisma.PrismaClientOptions['omit'] = Options extends { omit: infer U } ? U : Prisma.PrismaClientOptions['omit'],
    ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
  >(options: Prisma.Subset<Options, Prisma.PrismaClientOptions> ): PrismaClient<LogOpts, OmitOpts, ExtArgs>
}

/**
 * ## Prisma Client
 * 
 * Type-safe database client for TypeScript
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 * 
 * Read more in our [docs](https://pris.ly/d/client).
 */

export interface PrismaClient<
  in LogOpts extends Prisma.LogLevel = never,
  in out OmitOpts extends Prisma.PrismaClientOptions['omit'] = undefined,
  in out ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

  $on<V extends LogOpts>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): runtime.Types.Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): runtime.Types.Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): runtime.Types.Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => runtime.Types.Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): runtime.Types.Utils.JsPromise<R>

  $extends: runtime.Types.Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<OmitOpts>, ExtArgs, runtime.Types.Utils.Call<Prisma.TypeMapCb<OmitOpts>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.apiToken`: Exposes CRUD operations for the **ApiToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiTokens
    * const apiTokens = await prisma.apiToken.findMany()
    * ```
    */
  get apiToken(): Prisma.ApiTokenDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.projectMember`: Exposes CRUD operations for the **ProjectMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectMembers
    * const projectMembers = await prisma.projectMember.findMany()
    * ```
    */
  get projectMember(): Prisma.ProjectMemberDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.channel`: Exposes CRUD operations for the **Channel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Channels
    * const channels = await prisma.channel.findMany()
    * ```
    */
  get channel(): Prisma.ChannelDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.publication`: Exposes CRUD operations for the **Publication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Publications
    * const publications = await prisma.publication.findMany()
    * ```
    */
  get publication(): Prisma.PublicationDelegate<ExtArgs, { omit: OmitOpts }>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<ExtArgs, { omit: OmitOpts }>;
}

export function getPrismaClientClass(): PrismaClientConstructor {
  return runtime.getPrismaClient(config) as unknown as PrismaClientConstructor
}
